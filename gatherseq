#!/usr/bin/env perl
use strict;
use warnings;
use Getopt::Std;
use File::Basename;
use IO::Uncompress::AnyUncompress;

#......................................................................................

our $VERSION = "0.0.1";
our $EXE = basename($0);
#our $STDIN = '/dev/stdin'; # '-' will be replaced with this
our $URL = "https://github.com/tseemann/$EXE";

# default command line options
my %opt = (
 'm' => 1,
 'M' => 2,
 'F' => 'bohra',
);

#......................................................................................

sub usage {
  my($errcode) = @_;
  $errcode ||= 0;
  my $ofh = $errcode ? \*STDERR : \*STDOUT;
  print $ofh 
    "NAME\n  $EXE $VERSION\n",
    "SYNOPSIS\n  Scan and organize sequence files\n",
    "USAGE\n  $EXE [options] file.{gb,fa,fq,gff,gfa,clw,sth}[.gz,bz2,zip] > output.fasta\n",
    "OPTIONS\n",
    "  -h       Print this help\n",
    "  -v       Print version and exit\n",
    "  -q       No output while running, only errors\n",
    "  -m INT   Minimum depth to recurse [$opt{m}]\n",
    "  -M INT   Maximum depth to recurse [$opt{M}]\n",
    "  -F STR   Output format [$opt{F}]\n",
    "HOMEPAGE\n  $URL\n",
    "END\n";
  exit($errcode);
}

sub version {
  print "$EXE $VERSION\n";
  exit(0);
}

#......................................................................................

sub msg {
  print STDERR "@_\n" unless $opt{q};
}

sub err {
  print STDERR "ERROR: @_\n";
  exit(-1);
}

#......................................................................................

getopts('vhqm:M:', \%opt) or exit(-1);
$opt{v} and version();
$opt{h} and usage(0);
@ARGV or usage(1);

#......................................................................................

msg("This is $EXE $VERSION");

for my $fname (@ARGV) {
  msg("Opening '$fname'");
#  -d $fname and err("'$fname' is a directory not a file");
#  -r $fname or err("'$fname' is not readable");
  # read first line to see if we have any data
#  my $unzip = IO::Uncompress::AnyUncompress->new($fname);
##B  my $header = scalar(<$unzip>); # read first line
#  $header or err("The input appears to be empty");
}

msg("Done.");
exit(0);

#......................................................................................

sub parse_fasta {
  my($lines) = @_;
  my $count=0;
  for my $line (@$lines) {
    next if $line =~ m/^\s*$/;
    if ($line =~ m/^>/) {
      $count++;
    }
    else {
      $line = purify($line);
    }
    print $line;
  }
  return $count;
}

#......................................................................................

sub parse_fastq {
  my($lines) = @_;
  my $count=0;
  # jump 4 lines at a time
  for ( my $i=0 ; $i < $#{$lines} ; $i+=4 ) {
    print ">", substr($lines->[$i], 1);
    print purify( $lines->[$i+1] );
    $count++;
  }
  return $count;
}

#......................................................................................

